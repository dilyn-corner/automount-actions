#!/bin/sh

. "$SNAP/bin/common"

# Check if drive is mounted
check_drive() {
    log "Signal file is ${_watch_file}."

    while read -r _mount_point < "$_watch_file"; do
        [ -z "$_mount_point" ] && continue

        log "Mountpoint is ${_mount_point}."
        find_assertions "${_mount_point}"
    done
}

# Find any assertions on the root level of the mounted device
find_assertions() {
    _dir="$1"

    log "Assertions found are:" "$_dir"/*.assert
    ack_asserts "$_dir"/*.assert
}

# Submit some call to the snapd REST API
rest_call() {
    _action="$1"
    _file="$2"
    _snap_name=${2%%_*}
    _socket=/run/snapd.socket

    case "$_action" in
        ack)
            curl \
                -sS \
                -X POST \
                --data-binary "@$_file" \
                --unix-socket="$_socket" \
                http://localhost/v2/assertions
        ;;
        install)
            curl \
                -sS \
                -X POST \
                --form snap="@$_file" \
                --unix-socket="$_socket" \
                http://localhost/v2/snaps
        ;;
        track)
            curl \
                -sS \
                -X POST \
                --unix-socket="$_socket" \
                --header "Content-Type: application/json" \
                --data '{"action":"switch","channel":"stable"}' \
                "http://localhost/v2/snaps/${_snap_name}"
        ;;
    esac
}

# Acknowledge the found assertions using the snapd REST API
ack_asserts() {
    for _assert in "$@"; do
        if [ ! -e "${_assert%%.assert}.snap" ]; then
            log "ERROR: ${_assert%%.assert}.snap not found for $_assert"
            cp -f "$_log_file" "$_mount_point"
            exit 1
        fi

        # Create a list of snaps
        _snaps="$_snaps ${_assert%%.assert}.snap"

        # Ack the assert
        _response="$(rest_call ack "$_assert")"

        if echo "$_response" | grep -Iq '"status":"OK"'; then
            log "ACKNOWLEDGE RESULT: $_assert acknowledged"
        else
            log "ERROR: ACKNOWLEDGE RESULT: $_assert not acknowledged"
            cp -f "$_log_file" "$_mount_point"
            exit 1
        fi
    done

    install_snap "$_snaps"
}

# Install the asserted snap using the snapd REST API
install_snap() {
    for _snap in "$@"; do
        _snap_result="$SNAP_COMMON/${_snap##*/}_result.$_date"

        # install the snap
        _response="$(rest_call install "$_snap")"

        if echo "$_response" | grep -Iq '"status":"Accepted"'; then
            log "INSTALL RESULT: ${_snap##*/} installed"
        else
            log "ERROR: INSTALL RESULT: ${_snap##*/} not installed"
            cp -f "$_log_file" "$_mount_point"
            exit 1
        fi

        track_channel "${_snap##*/}" "$_snap_result"
    done
}

# set snapd to explicitly follow stable for a snap
track_channel() {
    # keep trying to set the channel to stable because it may take some time if a snap change is in process
    # give up after 14 loops, where each loop sleeps twice as long as the previous
    # where 14 loops takes 19.1 minutes
    _snap_name=${1%%_*}
    _log_name=$2
    _loop_count=0
    _sleep=2

    while [ $_loop_count -lt 14 ]; do
        sleep $_sleep
        _response="$(rest_call track "$_snap_name")"

        if echo "$_response" | grep -Iq '"status":"Accepted"'; then
            log "${_snap_name} is now following stable"
            cp -f "$_log_file" "$_mount_point"
            break
        fi

        _loop_count=$((_loop_count+1))
        _sleep=$((_sleep*2))
    done

    log "WARN: failed to make $_snap_name follow stable"
    log "WARN: Manual intervention may be required for $_snap_name to refresh"
    cp -f "$_log_file" "$_mount_point"
}

main() {
    # Globally set exit on error, no unset variables
    set -eu

    # Make a date time for logging
    _date=$(date -Iseconds); readonly _date
    readonly _log_file="$SNAP_COMMON/logs/auto-install/auto-install_${_date}.log"

    init_watch_file
    init_log "$_log_file"

    check_drive
}

[ -n "$NOEXEC" ] || main
