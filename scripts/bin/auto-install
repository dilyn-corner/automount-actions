#!/bin/sh

# Splitting isn't possible
# SNAP is not misspelt
# shellcheck disable=SC2086,SC2153

# log to SNAP_COMMON and TTY
log() {
    printf '%s %s\n' \
        "$(date -Iseconds)" "$1" | tee -a "${SNAP_COMMON}/auto-install.log"
}

# Check if drive is mounted
check_drive() {

    while :; do
        _watch_file="$SNAP_COMMON/watched"

        log "Signal file is ${_watch_file}."

        inotifywait -e open "$_watch_file"

        read -r _mount_point < "$_watch_file"

        [ -n "$_mount_point" ] || continue
    done

    log "Mountpoint is ${_mount_point}."
    find_assertions "${_mount_point}"
}

# Find any assertions on the root level of the mounted device
find_assertions() {
    _mount_point="$1"
    _assertions="$(find "$_mount_point" -maxdepth 1 -name '*.assert')"
    log "Assertions found are: $_assertions"
    ack_asserts $_assertions
}

# Acknowledge the found assertions using the snapd REST API
ack_asserts() {
    for _assert in "$@"; do
        if [ ! -e "${_assert%%.assert}.snap" ]; then
            log "ERROR: ${_assert%%.assert}.snap not found for $_assert"
            cp -f "${SNAP_COMMON}/auto-install.log" "$_mount_point"
            exit 1
        fi

        # Create a results file to check
        _assert_result="${SNAP_COMMON}/${_assert##*/}_result.$_date"
        # Create a list of snaps
        _snaps="$_snaps ${_assert%%.assert}.snap"
        # Ack the assert
        curl \
            -sS \
            -X POST \
            -o $_assert_result \
            --unix-socket /run/snapd.socket \
            --data-binary "@$_assert" \
            http://localhost/v2/assertions

        if grep -Iq '"status":"OK"' $_assert_result; then
            log "ACKNOWLEDGE RESULT: $_assert acknowledged"
        else
            log "ERROR: ACKNOWLEDGE RESULT: $_assert not acknowledged"
            cp -f "${SNAP_COMMON}/auto-install.log" "$_mount_point"
            exit 1
        fi
    done

    install_snap $_snaps
}

# Install the asserted snap using the snapd REST API
install_snap() {
    for _snap in "$@"; do
        _snap_result="$SNAP_COMMON/${_snap##*/}_result.$_date"
        # install the snap
        curl \
            -sS \
            -o "${_snap_result}" \
            --unix-socket /run/snapd.socket \
            --form snap=@$_snap \
            http://localhost/v2/snaps

        if grep -Iq '"status":"Accepted"' $_snap_result; then
            log "INSTALL RESULT: ${_snap##*/} installed"
        else
            log "ERROR: INSTALL RESULT: ${_snap##*/} not installed"
            cp -f "${SNAP_COMMON}/auto-install.log" "$_mount_point"
            exit 1
        fi

        track_channel ${_snap##*/} $_snap_result
    done
}

# set snapd to explicitly follow stable for a snap
track_channel() {
    # keep trying to set the channel to stable because it may take some time if a snap change is in process
    # give up after 14 loops, where each loop sleeps twice as long as the previous
    # where 14 loops takes 19.1 minutes
    _snap_name=${1%%_*}
    _loop_count=0
    _sleep=2

    while [ $_loop_count -lt 14 ]; do
        sleep $_sleep
        curl \
            -sS \
            -X POST \
            -o "${2}.channel" \
            --unix-socket /run/snapd.socket \
            --header "Content-Type: application/json" \
            --data '{"action":"switch","channel":"stable"}' \
            http://localhost/v2/snaps/${_snap_name}

        if grep -Iq '"status":"Accepted"' ${2}.channel; then
            log "${_snap_name} is now following stable"
            cp -f "${SNAP_COMMON}/auto-install.log" "$_mount_point"
            break
        fi
        _loop_count=$((_loop_count+1))
        _sleep=$((_sleep*2))
    done

    log "WARN: failed to make $_snap_name follow stable"
    log "WARN: Manual intervention may be required for $_snap_name to refresh"
    cp -f "${SNAP_COMMON}/auto-install.log" "$_mount_point"
}

main() {
    # Make a date time for logging
    _date=$(date -Iseconds)

    check_drive
}

main
