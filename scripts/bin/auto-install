#!/bin/sh

. "$SNAP/bin/common"

wait_for_fifo() {
    [ ! -p "$WATCH_FILE" ] || return

    _fifo="$(basename "$WATCH_FILE")"
    while :; do
        inotifywait --quiet --csv --event create "$(dirname "$WATCH_FILE")" | {
            IFS=, read -r _dir _ _name

            [ "$_name" != "$_fifo" ] || return
        }
    done
}

# Submit some call to the snapd REST API
rest_call() {
    _action="$1"
    _file="$2"

    _snap_name="$(basename "${2%%_*}")"
    _socket="${SNAPD_SOCKET:-/run/snapd.socket}"

    case "$_action" in
        ack)
            curl \
                -sS \
                -X POST \
                --data-binary "@$_file" \
                --unix-socket "$_socket" \
                http://localhost/v2/assertions
        ;;
        install)
            curl \
                -sS \
                -X POST \
                --form snap="@$_file" \
                --unix-socket "$_socket" \
                http://localhost/v2/snaps
        ;;
        track)
            curl \
                -sS \
                -X POST \
                --unix-socket "$_socket" \
                --header "Content-Type: application/json" \
                --data '{"action":"switch","channel":"stable"}' \
                "http://localhost/v2/snaps/${_snap_name}"
        ;;
    esac
}

# Acknowledge the found assertions using the snapd REST API
ack_assert() {
    _assert="$1"

    # Ack the assert
    _response="$(rest_call ack "$_assert")"

    if ! echo "$_response" | grep -Iq '"status":"OK"'; then
        log "ERROR: ACKNOWLEDGE RESULT: $_assert not acknowledged"
        return 1
    fi

    log "ACKNOWLEDGE RESULT: $_assert acknowledged"
}

# Install the asserted snap using the snapd REST API
install_snap() {
    _snap="$1"

    # install the snap
    _response="$(rest_call install "$_snap")"

    if ! echo "$_response" | grep -Iq '"status":"Accepted"'; then
        log "ERROR: INSTALL RESULT: ${_snap##*/} not installed"
        return 1
    fi

    log "INSTALL RESULT: ${_snap##*/} installed"
}

# set snapd to explicitly follow stable for a snap
track_stable() {
    # Keep trying to set the channel to stable because it may take some
    #   time if a snap change is in progress. Quadratically back off each loop,
    #   and quit after 9 loops, for a sum total of ~17 minutes.

    _snap_name="$1"

    _loop_count=0
    _sleep=2

    while
        _response="$(rest_call track "$_snap_name")"

        if echo "$_response" | grep -Iq '"status":"Accepted"'; then
            log "${_snap_name} is now following stable"
            return
        fi

        [ $_loop_count -lt 9 ]
    do
        sleep $_sleep

        : $(( _loop_count += 1 ))
        : $(( _sleep      *= 2 ))
    done

    log "WARN: failed to make $_snap_name follow stable"
    log "WARN: Manual intervention may be required for $_snap_name to refresh"
    return 1
}

eject_device() {
    # Try to copy log file over
    cp -f "$_log_file" "$_mount_point" || true

    sync
    umount "$_mount_point"
    eject "/dev/disk/by-uuid/$(basename "$_mount_point")"
}

process_mounts() {
    _watch_file="$1"

    while read -r _mount_point < "$_watch_file"; do

        # Make sure the mount actually exists
        [ -d "$_mount_point" ] || continue

        _log_file="$(mklog)"

        # Skip mounts that don't contain any asserts
        ls "$_mount_point"/*.assert >/dev/null 2>&1 || {
            log "WARN: No assertions found."
            eject_device
            continue
        }

        # Loop through each assert and, for those with a corresponding snap, install
        log "Mountpoint is ${_mount_point}."
        for _assert in "$_mount_point"/*.assert; do

            # Make sure a corresponding snap exists
            [ -e "${_assert%%.assert}.snap" ] || {
                log "WARN: ${_assert%%.assert}.snap not found for $_assert"
                continue
            }

            ack_assert "$_assert" \
                && install_snap "${_assert%.assert}.snap" \
                && track_stable "$(basename "${_assert%_*}")" \
                || continue
        done

        eject_device
    done
}

main() {
    # Globally set exit on error, no unset variables
    set -eu

    wait_for_fifo
    process_mounts "$WATCH_FILE"
}

[ -n "$NOEXEC" ] || main
