#!/bin/sh

wait_for_fifo() {
    [ ! -p "$WATCH_FILE" ] || return 0

    echo "Waiting for FIFO: ${WATCH_FILE}"
    inotifywait --quiet --csv --event create "$(dirname "$WATCH_FILE")" | \
        while IFS=, read -r _dir _ _name; do
            [ "${_dir}/${_name}" != "$WATCH_FILE" ] || return 0
        done
}

watch_devices() {
    inotifywait --quiet --monitor --event "moved_to" --event "delete" /dev/disk/by-uuid | \
        while read -r _parent _action _uuid; do
            case "$_action" in
                MOVED_TO) try_mount "$_parent" "$_uuid" ;;
                *) : ;;
            esac
        done
}

try_mount() {
    _parent="${1%/}"
    _uuid="$2"

    _source="${_parent}/${_uuid}"
    _target="${MOUNT_DIR}/${_uuid}"

    echo "${SNAP_NAME}.auto-mount found: ${_source}"

    ! grep -q "$_target" /proc/mounts || {
      echo "WARN: Device is already mounted at ${_target}"
      return 0
    }

    mkdir -p "$_target"
    if ! mount -o rw,sync -t "${FSTYPE:-vfat}" "$_source" "$_target" >/dev/null 2>&1; then
        echo "WARN: Could not mount ${_source} to ${_target}"
        rm -rf "$_target"
        return 0
    fi

    wait_for_fifo
    echo "$_target" >> "$WATCH_FILE"
}

cleanup () {
    _exit_status=$?

    [ -z "${CLEANUP_HAS_RUN:-}" ] || return 0
    CLEANUP_HAS_RUN=1

    sync

    _uuids="$(ls -1 "$MOUNT_DIR" | tr '\n' :)"
    if [ -n "$_uuids" ]; then
        # Unmount everthing
        IFS=:
        for _uuid in $_uuids; do
            umount "${MOUNT_DIR}/${_uuid}" || continue
            rmdir "${MOUNT_DIR}/${_uuid}"
        done
    fi

    rmdir "$MOUNT_DIR"

    # Exit with 0 if we're interrupted with INT or TERM
    case $_exit_status in 130|143) exit 0; esac
}

main() {
    set -eu

    : "${WATCH_FILE:=/tmp/mounts.fifo}"; readonly WATCH_FILE
    : "${MOUNT_DIR:="$(mktemp -d)"}";    readonly MOUNT_DIR

    trap cleanup EXIT INT TERM

    watch_devices
}

[ -n "$NOEXEC" ] || main
